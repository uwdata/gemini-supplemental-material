<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style> /* set the CSS */
  .mark {
    fill: steelblue;
  }
  .title {
    font-family: sans-serif;
    font-size: 11px;
    font-weight: bold;
  }
  .legend .label {
    font-family: sans-serif;
    font-size: 10px;
  }
  .legend .point {
    opacity: 0.7;
    fill: transparent;
    stroke-width: 1.5px;
  }
  .point {
    opacity: 0.7;
    fill: transparent;
    stroke-width: 2px;
  }

  .domain {
    stroke: rgb(136, 136, 136)
  }
  .tick line {
    stroke: rgb(136, 136, 136)
  }

  .grid .tick line{
    fill: none;
    stroke: rgb(221, 221, 221);
    stroke-width: 1px;
  }
  .grid .domain{
    stroke: none;
  }
  </style>
</head>

<body>

</script>
</body>


<body>
  <div id="view"></div>
  <script>
  const margin = { top: 20, right: 60, bottom: 90, left: 40 };

  const height = 160;
  const svg = d3
    .select("#view")
    .append("svg")

  const root = svg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  const view = document.getElementById("view")
  const theDate = new Date("2020-01-21");
  d3.json("data.json").then(sourceData => {
    // data
    const data = sourceData.map(d => {
      let publishedDate = new Date(d.published);
      return {
        ...d,
        howLong: (theDate.getFullYear() - publishedDate.getFullYear()) + (theDate.getMonth() - publishedDate.getMonth())/12
      }
    }).sort((a,b) => b.views - a.views);

    const titles = data.map(d => d.title);
    const width = titles.length * 20;


    svg.attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)

    // scales
    const x = d3.scaleBand().range([0, width]).padding(0.1)
      .domain(titles);

    const xl = d3.scaleBand().range([0, width]).padding(0.1)
      .domain(data.sort((a,b) => b.howLong - a.howLong).map(d => d.title));

    const y = d3.scaleLinear().range([height, 0]);
    const viewsExtent = d3.extent(data, d => d.views);
    y.domain([Math.min(viewsExtent[0], 0), viewsExtent[1]]).nice();

    const yl = d3.scaleLinear().range([height, 0]);
    const howLongExtent = d3.extent(data, d => d.howLong);
    yl.domain([Math.min(howLongExtent[0], 0), howLongExtent[1]]).nice();


    // x axis
    const xGrp = root.append("g")
      .attr("class", "xGrp");

    xAxis = xGrp.append("g").attr("class", `xAxis`)
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x).ticks(4));

    xGrp.selectAll(".tick text")
      .attr("transform", `translate(6,1)rotate(45)`)
      .attr("text-anchor", "start")

    xGrp.append("text")
      .attr("class", "title")
      .attr("transform", `translate(${width / 2}, ${height + margin.top + margin.bottom - 25})`)
      .text("Clip")

    // y axis
    const yGrp = root.append("g")
      .attr("class", "yGrp");

    yGrid = yGrp.append("g")
      .attr("class", `grid y`)
      .call(d3.axisLeft(y).ticks(4).tickSize(-width).tickFormat(""))
      .call(g => g.select(".domain").remove());

    yAxis = yGrp.append("g").attr("class", `axis`).call(d3.axisLeft(y).ticks(4, ".1f"));

    yTitle = yGrp.append("text")
      .attr("class", "title")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x", 0 - height / 2)
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Views (billion)")

    // marks
    const marks = root.append("g")
      .attr("class", "marks")

    const bars = marks.selectAll(".mark")
      .data(data, d => d.title).enter()
      .append("rect")
      .attr("class", "mark")
      .attr("x", d => x(d.title))
      .attr("width", d => x.bandwidth())
      .attr("y", d => y(d.views))
      .attr("height", d => y(0) - y(d.views))

    const D_START = 500   // at 0.5 sec, animation starts
    const D_GROW = 2500   // at 2.5 sec, things start to grow
    const D_SORT = 4500   // at 4.5 sec, sorting starts
    const DUR = 1500      // 1.5 sec duration, so there is a 0.5 sec break before the next stage happens

    // at 0.5 sec, shrink while fading out the old marks and the old y axis
    // Initially I tried shrinking and fading out independently.
    // I thought shrinking was better because the visual change is bigger,
    // making it more obvious that there's data change on the y axis.
    // I ended up using both effects, maximizing the visual signal that we
    // are changing data!)
    bars.transition().duration(DUR).delay(D_START)
      .attr("height", 0)
      .attr("y", 160)
      .style("opacity", 0.3)

    yGrp.transition().duration(DUR).delay(D_START)
      .attr("transform", "translate(0,160) scale(1,0)")
      .style("opacity", 0.3)


    // at 2.5 sec, grow while fading in the new marks and the new y axis
    bars.transition().duration(DUR).delay(D_GROW)
      .attr("y", d => yl(d.howLong))
      .attr("height", d => yl(0) - yl(d.howLong))
      .style("opacity", 1)

    yGrp.transition().duration(DUR).delay(D_GROW)
      .attr("transform", "translate(0,0) scale(1,1)")
      .style("opacity", 1)

    yTitle.transition().delay(D_GROW)
      .text("Posted For (year)")

    yGrid.transition().delay(D_GROW)
      .call(d3.axisLeft(yl).ticks(4).tickSize(-width).tickFormat(""))
      .call(g => g.select(".domain").remove());

    yAxis.transition().delay(D_GROW)
      .call(d3.axisLeft(yl).ticks(4, ".1f"))


    // at 4.5 sec, re-order bars and titles
    bars.transition().duration(DUR).delay(D_SORT)
      .attr("x", d => xl(d.title))

    xAxis.transition().duration(DUR).delay(D_SORT)
      .call(d3.axisBottom(xl).ticks(4));
  })

  </script>
</body>