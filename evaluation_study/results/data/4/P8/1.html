<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <!-- <script src="d3.v5.min.js"></script> -->
  <!-- YH: added -->
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style> /* set the CSS */
  .mark {
    fill: steelblue;
    stroke: steelblue;
  }
  .mark.line {
    stroke-width: 2px;
    fill: transparent;
  }
  .title {
    font-family: sans-serif;
    font-size: 11px;
    font-weight: bold;
  }
  .legend .label {
    font-family: sans-serif;
    font-size: 10px;
  }
  .legend .point {
    opacity: 0.7;
    fill: transparent;
    stroke-width: 1.5px;
  }
  .legend .line {
    fill: transparent;
    stroke-width: 2px;
  }

  .point {
    opacity: 0.7;
    fill: transparent;
    stroke-width: 2px;
  }

  .domain {
    stroke: rgb(136, 136, 136)
  }
  .tick line {
    stroke: rgb(136, 136, 136)
  }

  .grid .tick line{
    fill: none;
    stroke: rgb(221, 221, 221);
    stroke-width: 1px;
  }
  .grid .domain{
    stroke: none;
  }
  </style>
</head>

<body>

</script>
</body>


<body>
  <div id="view"></div>
  <script>
  const margin = { top: 20, right: 65, bottom: 50, left: 40 };

  const height = 200;
  const radius = 2.75;;
  const svg = d3
    .select("#view")
    .append("svg")

  const root = svg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  const view = document.getElementById("view")

  d3.json("data.json").then(sourceData => {
    // data
    const formatTime = d3.timeFormat("%b");

    const aggNest = d3.nest().key(d => formatTime(new Date(d.date)))
      .rollup(values => d3.mean(values, d => d.temp_max));
    const aggregatedData = aggNest.entries(sourceData)
    const aggObj =  d3.nest().key(d => formatTime(new Date(d.date)))
      .rollup(values => d3.mean(values, d => d.temp_max))
      .object(sourceData);


    const data = sourceData.map(d => {
      return {
        ...d,
        monthNum: new Date(d.date).getMonth(),
        monthStr: formatTime(new Date(d.date)),
        mean: aggObj[formatTime(new Date(d.date))]
      };

    })






    const months = d3.map(data, d => d.monthStr).keys();
    const width = months.length * 20;
    svg.attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)

    // scales
    const x = d3.scaleBand().range([0, width]).padding(0.5);
    x.domain(months);

    const y = d3.scaleLinear().range([height, 0]);
    const maxTempExtent = d3.extent(data, d => d.temp_max);
    y.domain([Math.min(maxTempExtent[0], 0), maxTempExtent[1]]).nice();





    // x axis
    const xAxis = root.append("g")
      .attr("class", "xAxis");


    xAxis.append("g").attr("class", `xAxis`)
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x));

    xAxis.selectAll(".tick text")
      .attr("transform", `rotate(90)translate(10,-12)`)
      .attr("text-anchor", "start")

    xAxis.append("text")
      .attr("class", "title")
      .attr("transform", `translate(${width / 2}, ${height + margin.top + margin.bottom - 25})`)
      .text("Month")

    // y axis
    const yAxis = root.append("g")
      .attr("class", "yAxis");

    yAxis.append("g")
      .attr("class", `grid y`)
      .call(d3.axisLeft(y).ticks(5).tickSize(-width).tickFormat(""))
      .call(g => g.select(".domain").remove());

    yAxis.append("g").attr("class", `axis`).call(d3.axisLeft(y).ticks(5));

    yAxis
      .append("text")
      .attr("class", "title")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x", 0 - height / 2)
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Max. Temperature (â„ƒ)");



    // marks

    const marks = root.append("g")
      .attr("class", "marks")


    const points = marks.selectAll(".mark")
      .data(data, d => d.date)

    var enter_points = points.enter()
      .append("ellipse")
      .attr("class", "mark point")
      .attr("cx", d => x(d.monthStr))
      .attr("cy", d => y(d.temp_max))
      .attr("rx", radius)
      .attr("ry", radius)
      .transition()
      .delay(1000)
      .attr("ry", 0.1)



    // work on overlaying the recatangle
    const rect_marks = root.append("g")
      .attr("class", "marks")

    const rects = rect_marks.selectAll(".mark")
      .data(aggregatedData, d => d.key)



    var entered_rects = rects.enter()
      .append("rect")
      .attr("x", d => x(d.key)-(x.bandwidth()/2))
      .attr("width", d => x.bandwidth())
      .attr("y", d => y(d.value))
      .attr("height", d => 2)
      .attr("color", "red")
      .attr("fill", "red")
      .attr("fill-opacity", 0)

    entered_rects.transition()
      .duration(2000)
      .attr("fill-opacity", 1)

    var _n = 0;
    enter_points.transition()
      .ease(d3.easeExp)
      .delay(500)
      .duration(1000)
      .attr("cy", d => y(d.mean))
      .remove()
      .each(d => {_n++;})
      .on("end", function(){
        if(!--_n){
          entered_rects.transition()
            .attr("class", "mark bar")
            .duration(500)
            .attr("height", d => y(0) - y(d.value))
          }
      })








  })
  </script>
</body>